<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/EvanOxfeld/node-unzip">unzip (v0.1.11)</a>
</h1>
<h4>Unzip cross-platform streaming API compatible with fstream and fs.ReadStream</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip">module unzip</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract">
            function <span class="apidocSignatureSpan">unzip.</span>Extract
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.prototype._write">
            function <span class="apidocSignatureSpan">unzip.</span>Extract.prototype._write
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.super_">
            function <span class="apidocSignatureSpan">unzip.</span>Extract.super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.super_.prototype._write">
            function <span class="apidocSignatureSpan">unzip.</span>Extract.super_.prototype._write
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.super_.prototype.end">
            function <span class="apidocSignatureSpan">unzip.</span>Extract.super_.prototype.end
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.super_.prototype.pipe">
            function <span class="apidocSignatureSpan">unzip.</span>Extract.super_.prototype.pipe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.super_.prototype.write">
            function <span class="apidocSignatureSpan">unzip.</span>Extract.super_.prototype.write
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse">
            function <span class="apidocSignatureSpan">unzip.</span>Parse
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._flush">
            function <span class="apidocSignatureSpan">unzip.</span>Parse.prototype._flush
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._processDataDescriptor">
            function <span class="apidocSignatureSpan">unzip.</span>Parse.prototype._processDataDescriptor
            <span class="apidocSignatureSpan">(entry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._readCentralDirectoryFileHeader">
            function <span class="apidocSignatureSpan">unzip.</span>Parse.prototype._readCentralDirectoryFileHeader
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._readEndOfCentralDirectoryRecord">
            function <span class="apidocSignatureSpan">unzip.</span>Parse.prototype._readEndOfCentralDirectoryRecord
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._readFile">
            function <span class="apidocSignatureSpan">unzip.</span>Parse.prototype._readFile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._readRecord">
            function <span class="apidocSignatureSpan">unzip.</span>Parse.prototype._readRecord
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._transform">
            function <span class="apidocSignatureSpan">unzip.</span>Parse.prototype._transform
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype.addListener">
            function <span class="apidocSignatureSpan">unzip.</span>Parse.prototype.addListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype.pipe">
            function <span class="apidocSignatureSpan">unzip.</span>Parse.prototype.pipe
            <span class="apidocSignatureSpan">(dest, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.super_">
            function <span class="apidocSignatureSpan">unzip.</span>Parse.super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.super_.prototype._read">
            function <span class="apidocSignatureSpan">unzip.</span>Parse.super_.prototype._read
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.super_.prototype._transform">
            function <span class="apidocSignatureSpan">unzip.</span>Parse.super_.prototype._transform
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.super_.prototype._write">
            function <span class="apidocSignatureSpan">unzip.</span>Parse.super_.prototype._write
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.super_.prototype.push">
            function <span class="apidocSignatureSpan">unzip.</span>Parse.super_.prototype.push
            <span class="apidocSignatureSpan">(chunk, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.entry">
            function <span class="apidocSignatureSpan">unzip.</span>entry
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">unzip.</span>Extract.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">unzip.</span>Extract.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">unzip.</span>Parse.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">unzip.</span>Parse.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">unzip.</span>Parse.super_.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">unzip.</span>entry.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Extract">module unzip.Extract</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.Extract">
            function <span class="apidocSignatureSpan">unzip.</span>Extract
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.super_">
            function <span class="apidocSignatureSpan">unzip.Extract.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Extract.prototype">module unzip.Extract.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.prototype._write">
            function <span class="apidocSignatureSpan">unzip.Extract.prototype.</span>_write
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Extract.prototype._write">module unzip.Extract.prototype._write</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.prototype._write._write">
            function <span class="apidocSignatureSpan">unzip.Extract.prototype.</span>_write
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Extract.super_">module unzip.Extract.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.super_.super_">
            function <span class="apidocSignatureSpan">unzip.Extract.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.super_.WritableState">
            function <span class="apidocSignatureSpan">unzip.Extract.super_.</span>WritableState
            <span class="apidocSignatureSpan">(options, stream)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Extract.super_.prototype">module unzip.Extract.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.super_.prototype._write">
            function <span class="apidocSignatureSpan">unzip.Extract.super_.prototype.</span>_write
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.super_.prototype.end">
            function <span class="apidocSignatureSpan">unzip.Extract.super_.prototype.</span>end
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.super_.prototype.pipe">
            function <span class="apidocSignatureSpan">unzip.Extract.super_.prototype.</span>pipe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.super_.prototype.write">
            function <span class="apidocSignatureSpan">unzip.Extract.super_.prototype.</span>write
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Extract.super_.prototype._write">module unzip.Extract.super_.prototype._write</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.super_.prototype._write._write">
            function <span class="apidocSignatureSpan">unzip.Extract.super_.prototype.</span>_write
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Extract.super_.prototype.end">module unzip.Extract.super_.prototype.end</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.super_.prototype.end.end">
            function <span class="apidocSignatureSpan">unzip.Extract.super_.prototype.</span>end
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Extract.super_.prototype.pipe">module unzip.Extract.super_.prototype.pipe</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.super_.prototype.pipe.pipe">
            function <span class="apidocSignatureSpan">unzip.Extract.super_.prototype.</span>pipe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Extract.super_.prototype.write">module unzip.Extract.super_.prototype.write</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Extract.super_.prototype.write.write">
            function <span class="apidocSignatureSpan">unzip.Extract.super_.prototype.</span>write
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Parse">module unzip.Parse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.Parse">
            function <span class="apidocSignatureSpan">unzip.</span>Parse
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.create">
            function <span class="apidocSignatureSpan">unzip.Parse.</span>create
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.super_">
            function <span class="apidocSignatureSpan">unzip.Parse.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Parse.prototype">module unzip.Parse.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._flush">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_flush
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._processDataDescriptor">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_processDataDescriptor
            <span class="apidocSignatureSpan">(entry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._readCentralDirectoryFileHeader">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_readCentralDirectoryFileHeader
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._readEndOfCentralDirectoryRecord">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_readEndOfCentralDirectoryRecord
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._readFile">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_readFile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._readRecord">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_readRecord
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._transform">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype.addListener">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>addListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype.on">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>on
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype.pipe">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>pipe
            <span class="apidocSignatureSpan">(dest, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Parse.prototype._flush">module unzip.Parse.prototype._flush</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._flush._flush">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_flush
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Parse.prototype._processDataDescriptor">module unzip.Parse.prototype._processDataDescriptor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._processDataDescriptor._processDataDescriptor">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_processDataDescriptor
            <span class="apidocSignatureSpan">(entry)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Parse.prototype._readCentralDirectoryFileHeader">module unzip.Parse.prototype._readCentralDirectoryFileHeader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._readCentralDirectoryFileHeader._readCentralDirectoryFileHeader">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_readCentralDirectoryFileHeader
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Parse.prototype._readEndOfCentralDirectoryRecord">module unzip.Parse.prototype._readEndOfCentralDirectoryRecord</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._readEndOfCentralDirectoryRecord._readEndOfCentralDirectoryRecord">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_readEndOfCentralDirectoryRecord
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Parse.prototype._readFile">module unzip.Parse.prototype._readFile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._readFile._readFile">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_readFile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Parse.prototype._readRecord">module unzip.Parse.prototype._readRecord</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._readRecord._readRecord">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_readRecord
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Parse.prototype._transform">module unzip.Parse.prototype._transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype._transform._transform">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Parse.prototype.addListener">module unzip.Parse.prototype.addListener</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype.addListener.addListener">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>addListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Parse.prototype.pipe">module unzip.Parse.prototype.pipe</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.prototype.pipe.pipe">
            function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>pipe
            <span class="apidocSignatureSpan">(dest, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Parse.super_">module unzip.Parse.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.super_.super_">
            function <span class="apidocSignatureSpan">unzip.Parse.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Parse.super_.prototype">module unzip.Parse.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.super_.prototype._read">
            function <span class="apidocSignatureSpan">unzip.Parse.super_.prototype.</span>_read
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.super_.prototype._transform">
            function <span class="apidocSignatureSpan">unzip.Parse.super_.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.super_.prototype._write">
            function <span class="apidocSignatureSpan">unzip.Parse.super_.prototype.</span>_write
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.super_.prototype.push">
            function <span class="apidocSignatureSpan">unzip.Parse.super_.prototype.</span>push
            <span class="apidocSignatureSpan">(chunk, encoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Parse.super_.prototype._read">module unzip.Parse.super_.prototype._read</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.super_.prototype._read._read">
            function <span class="apidocSignatureSpan">unzip.Parse.super_.prototype.</span>_read
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Parse.super_.prototype._transform">module unzip.Parse.super_.prototype._transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.super_.prototype._transform._transform">
            function <span class="apidocSignatureSpan">unzip.Parse.super_.prototype.</span>_transform
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Parse.super_.prototype._write">module unzip.Parse.super_.prototype._write</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.super_.prototype._write._write">
            function <span class="apidocSignatureSpan">unzip.Parse.super_.prototype.</span>_write
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Parse.super_.prototype.push">module unzip.Parse.super_.prototype.push</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.super_.prototype.push.push">
            function <span class="apidocSignatureSpan">unzip.Parse.super_.prototype.</span>push
            <span class="apidocSignatureSpan">(chunk, encoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.Parse.super_.super_.prototype">module unzip.Parse.super_.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.super_.super_.prototype._write">
            function <span class="apidocSignatureSpan">unzip.Parse.super_.super_.prototype.</span>_write
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.super_.super_.prototype.end">
            function <span class="apidocSignatureSpan">unzip.Parse.super_.super_.prototype.</span>end
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.Parse.super_.super_.prototype.write">
            function <span class="apidocSignatureSpan">unzip.Parse.super_.super_.prototype.</span>write
            <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.entry">module unzip.entry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.entry.entry">
            function <span class="apidocSignatureSpan">unzip.</span>entry
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.entry.super_">
            function <span class="apidocSignatureSpan">unzip.entry.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.unzip.entry.prototype">module unzip.entry.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.unzip.entry.prototype.autodrain">
            function <span class="apidocSignatureSpan">unzip.entry.prototype.</span>autodrain
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip" id="apidoc.module.unzip">module unzip</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Extract" id="apidoc.element.unzip.Extract">
        function <span class="apidocSignatureSpan">unzip.</span>Extract
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Extract(opts) {
  var self = this;
  if (!(this instanceof Extract)) {
    return new Extract(opts);
  }

  Writable.apply(this);
  this._opts = opts || { verbose: false };

  this._parser = Parse(this._opts);
  this._parser.on('error', function(err) {
    self.emit('error', err);
  });
  this.on('finish', function() {
    self._parser.end();
  });

  var writer = Writer({
    type: 'Directory',
    path: opts.path
  });
  writer.on('error', function(err) {
    self.emit('error', err);
  });
  writer.on('close', function() {
    self.emit('close')
  });

  this.on('pipe', function(source) {
    if (opts.verbose &amp;&amp; source.path) {
      console.log('Archive: ', source.path);
    }
  });

  this._parser.pipe(writer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
$ npm install unzip
```

## Quick Examples

### Extract to a directory
```javascript
fs.createReadStream('path/to/archive.zip').pipe(unzip.<span class="apidocCodeKeywordSpan">Extract</span>({ path: '
;output/path' }));
```

Extract emits the 'close' event once the zip's contents have been fully extracted to disk.

### Parse zip file contents

Process each zip file entry or pipe entries to another stream.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Extract.prototype._write" id="apidoc.element.unzip.Extract.prototype._write">
        function <span class="apidocSignatureSpan">unzip.</span>Extract.prototype._write
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Extract.prototype._write = function (chunk, encoding, callback) {
  if (this._parser.write(chunk)) {
    return callback();
  }

  return this._parser.once('drain', callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Extract.super_" id="apidoc.element.unzip.Extract.super_">
        function <span class="apidocSignatureSpan">unzip.</span>Extract.super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) &amp;&amp; !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Extract.super_.prototype._write" id="apidoc.element.unzip.Extract.super_.prototype._write">
        function <span class="apidocSignatureSpan">unzip.</span>Extract.super_.prototype._write
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Extract.super_.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('not implemented'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Extract.super_.prototype.end" id="apidoc.element.unzip.Extract.super_.prototype.end">
        function <span class="apidocSignatureSpan">unzip.</span>Extract.super_.prototype.end
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Extract.super_.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' &amp;&amp; chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending &amp;&amp; !state.finished)
    endWritable(this, state, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Extract.super_.prototype.pipe" id="apidoc.element.unzip.Extract.super_.prototype.pipe">
        function <span class="apidocSignatureSpan">unzip.</span>Extract.super_.prototype.pipe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Extract.super_.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Extract.super_.prototype.write" id="apidoc.element.unzip.Extract.super_.prototype.write">
        function <span class="apidocSignatureSpan">unzip.</span>Extract.super_.prototype.write
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Extract.super_.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse" id="apidoc.element.unzip.Parse">
        function <span class="apidocSignatureSpan">unzip.</span>Parse
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parse(opts) {
  var self = this;
  if (!(this instanceof Parse)) {
    return new Parse(opts);
  }

  Transform.call(this, { lowWaterMark: 0 });
  this._opts = opts || { verbose: false };
  this._hasEntryListener = false;

  this._pullStream = new PullStream();
  this._pullStream.on("error", function (e) {
    self.emit('error', e);
  });
  this._pullStream.once("end", function () {
    self._streamEnd = true;
  });
  this._pullStream.once("finish", function () {
    self._streamFinish = true;
  });

  this._readRecord();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Process each zip file entry or pipe entries to another stream.

__Important__: If you do not intend to consume an entry stream's raw data, call autodrain() to dispose of the entry's
contents. Otherwise you risk running out of memory.

```javascript
fs.createReadStream('path/to/archive.zip')
.pipe(unzip.<span class="apidocCodeKeywordSpan">Parse</span>())
.on('entry', function (entry) {
  var fileName = entry.path;
  var type = entry.type; // 'Directory' or 'File'
  var size = entry.size;
  if (fileName === "this IS the file I'm looking for") {
    entry.pipe(fs.createWriteStream('output/path'));
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._flush" id="apidoc.element.unzip.Parse.prototype._flush">
        function <span class="apidocSignatureSpan">unzip.</span>Parse.prototype._flush
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Parse.prototype._flush = function (callback) {
  if (!this._streamEnd || !this._streamFinish) {
    return setImmediate(this._flush.bind(this, callback));
  }

  this.emit('close');
  return callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._processDataDescriptor" id="apidoc.element.unzip.Parse.prototype._processDataDescriptor">
        function <span class="apidocSignatureSpan">unzip.</span>Parse.prototype._processDataDescriptor
        <span class="apidocSignatureSpan">(entry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Parse.prototype._processDataDescriptor = function (entry) {
  var self = this;
  this._pullStream.pull(16, function (err, data) {
    if (err) {
      return self.emit('error', err);
    }

    var vars = binary.parse(data)
      .word32lu('dataDescriptorSignature')
      .word32lu('crc32')
      .word32lu('compressedSize')
      .word32lu('uncompressedSize')
      .vars;

    entry.size = vars.uncompressedSize;
    self._readRecord();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._readCentralDirectoryFileHeader" id="apidoc.element.unzip.Parse.prototype._readCentralDirectoryFileHeader">
        function <span class="apidocSignatureSpan">unzip.</span>Parse.prototype._readCentralDirectoryFileHeader
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Parse.prototype._readCentralDirectoryFileHeader = function () {
  var self = this;
  this._pullStream.pull(42, function (err, data) {
    if (err) {
      return self.emit('error', err);
    }

    var vars = binary.parse(data)
      .word16lu('versionMadeBy')
      .word16lu('versionsNeededToExtract')
      .word16lu('flags')
      .word16lu('compressionMethod')
      .word16lu('lastModifiedTime')
      .word16lu('lastModifiedDate')
      .word32lu('crc32')
      .word32lu('compressedSize')
      .word32lu('uncompressedSize')
      .word16lu('fileNameLength')
      .word16lu('extraFieldLength')
      .word16lu('fileCommentLength')
      .word16lu('diskNumber')
      .word16lu('internalFileAttributes')
      .word32lu('externalFileAttributes')
      .word32lu('offsetToLocalFileHeader')
      .vars;

    return self._pullStream.pull(vars.fileNameLength, function (err, fileName) {
      if (err) {
        return self.emit('error', err);
      }
      fileName = fileName.toString('utf8');

      self._pullStream.pull(vars.extraFieldLength, function (err, extraField) {
        if (err) {
          return self.emit('error', err);
        }
        self._pullStream.pull(vars.fileCommentLength, function (err, fileComment) {
          if (err) {
            return self.emit('error', err);
          }
          return self._readRecord();
        });
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._readEndOfCentralDirectoryRecord" id="apidoc.element.unzip.Parse.prototype._readEndOfCentralDirectoryRecord">
        function <span class="apidocSignatureSpan">unzip.</span>Parse.prototype._readEndOfCentralDirectoryRecord
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Parse.prototype._readEndOfCentralDirectoryRecord = function () {
  var self = this;
  this._pullStream.pull(18, function (err, data) {
    if (err) {
      return self.emit('error', err);
    }

    var vars = binary.parse(data)
      .word16lu('diskNumber')
      .word16lu('diskStart')
      .word16lu('numberOfRecordsOnDisk')
      .word16lu('numberOfRecords')
      .word32lu('sizeOfCentralDirectory')
      .word32lu('offsetToStartOfCentralDirectory')
      .word16lu('commentLength')
      .vars;

    if (vars.commentLength) {
      setImmediate(function() {
        self._pullStream.pull(vars.commentLength, function (err, comment) {
          if (err) {
            return self.emit('error', err);
          }
          comment = comment.toString('utf8');
          return self._pullStream.end();
        });
      });

    } else {
      self._pullStream.end();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._readFile" id="apidoc.element.unzip.Parse.prototype._readFile">
        function <span class="apidocSignatureSpan">unzip.</span>Parse.prototype._readFile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Parse.prototype._readFile = function () {
  var self = this;
  this._pullStream.pull(26, function (err, data) {
    if (err) {
      return self.emit('error', err);
    }

    var vars = binary.parse(data)
      .word16lu('versionsNeededToExtract')
      .word16lu('flags')
      .word16lu('compressionMethod')
      .word16lu('lastModifiedTime')
      .word16lu('lastModifiedDate')
      .word32lu('crc32')
      .word32lu('compressedSize')
      .word32lu('uncompressedSize')
      .word16lu('fileNameLength')
      .word16lu('extraFieldLength')
      .vars;

    return self._pullStream.pull(vars.fileNameLength, function (err, fileName) {
      if (err) {
        return self.emit('error', err);
      }
      fileName = fileName.toString('utf8');
      var entry = new Entry();
      entry.path = fileName;
      entry.props.path = fileName;
      entry.type = (vars.compressedSize === 0 &amp;&amp; /[\/\\]$/.test(fileName)) ? 'Directory' : 'File';

      if (self._opts.verbose) {
        if (entry.type === 'Directory') {
          console.log('   creating:', fileName);
        } else if (entry.type === 'File') {
          if (vars.compressionMethod === 0) {
            console.log(' extracting:', fileName);
          } else {
            console.log('  inflating:', fileName);
          }
        }
      }

      var hasEntryListener = self._hasEntryListener;
      if (hasEntryListener) {
        self.emit('entry', entry);
      }

      self._pullStream.pull(vars.extraFieldLength, function (err, extraField) {
        if (err) {
          return self.emit('error', err);
        }
        if (vars.compressionMethod === 0) {
          self._pullStream.pull(vars.compressedSize, function (err, compressedData) {
            if (err) {
              return self.emit('error', err);
            }

            if (hasEntryListener) {
              entry.write(compressedData);
              entry.end();
            }

            return self._readRecord();
          });
        } else {
          var fileSizeKnown = !(vars.flags &amp; 0x08);

          var inflater = zlib.createInflateRaw();
          inflater.on('error', function (err) {
            self.emit('error', err);
          });

          if (fileSizeKnown) {
            entry.size = vars.uncompressedSize;
            if (hasEntryListener) {
              entry.on('finish', self._readRecord.bind(self));
              self._pullStream.pipe(vars.compressedSize, inflater).pipe(entry);
            } else {
              self._pullStream.drain(vars.compressedSize, function (err) {
                if (err) {
                  return self.emit('error', err);
                }
                self._readRecord();
              });
            }
          } else {
            var descriptorSig = new Buffer(4);
            descriptorSig.writeUInt32LE(0x08074b50, 0);

            var matchStream = new MatchStream({ pattern: descriptorSig }, function (buf, matched, extra) {
              if (hasEntryListener) {
                if (!matched) {
                  return this.push(buf);
                }
                this.push(buf);
              }
              setImmediate(function() {
                self._pullStream.unpipe();
                self._pullStream.prepend(extra);
                self._processDataDescriptor(entry);
              });
              return this.push(null);
            });

            self._pullStream.pipe(matchStream);
            if (hasEntryListener) {
              matchStream.pipe(inflater).pipe(entry);
            }
          }
        }
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._readRecord" id="apidoc.element.unzip.Parse.prototype._readRecord">
        function <span class="apidocSignatureSpan">unzip.</span>Parse.prototype._readRecord
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Parse.prototype._readRecord = function () {
  var self = this;
  this._pullStream.pull(4, function (err, data) {
    if (err) {
      return self.emit('error', err);
    }

    if (data.length === 0) {
      return;
    }

    var signature = data.readUInt32LE(0);
    if (signature === 0x04034b50) {
      self._readFile();
    } else if (signature === 0x02014b50) {
      self._readCentralDirectoryFileHeader();
    } else if (signature === 0x06054b50) {
      self._readEndOfCentralDirectoryRecord();
    } else {
      err = new Error('invalid signature: 0x' + signature.toString(16));
      self.emit('error', err);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._transform" id="apidoc.element.unzip.Parse.prototype._transform">
        function <span class="apidocSignatureSpan">unzip.</span>Parse.prototype._transform
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Parse.prototype._transform = function (chunk, encoding, callback) {
  if (this._pullStream.write(chunk)) {
    return callback();
  }

  this._pullStream.once('drain', callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype.addListener" id="apidoc.element.unzip.Parse.prototype.addListener">
        function <span class="apidocSignatureSpan">unzip.</span>Parse.prototype.addListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Parse.prototype.addListener = function (type, listener) {
  if ('entry' === type) {
    this._hasEntryListener = true;
  }
  return Transform.prototype.addListener.call(this, type, listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype.pipe" id="apidoc.element.unzip.Parse.prototype.pipe">
        function <span class="apidocSignatureSpan">unzip.</span>Parse.prototype.pipe
        <span class="apidocSignatureSpan">(dest, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Parse.prototype.pipe = function (dest, opts) {
  var self = this;
  if (typeof dest.add === "function") {
    self.on("entry", function (entry) {
      dest.add(entry);
    })
  }
  return Transform.prototype.pipe.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.super_" id="apidoc.element.unzip.Parse.super_">
        function <span class="apidocSignatureSpan">unzip.</span>Parse.super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.super_.prototype._read" id="apidoc.element.unzip.Parse.super_.prototype._read">
        function <span class="apidocSignatureSpan">unzip.</span>Parse.super_.prototype._read
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Parse.super_.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null &amp;&amp; ts.writecb &amp;&amp; !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.super_.prototype._transform" id="apidoc.element.unzip.Parse.super_.prototype._transform">
        function <span class="apidocSignatureSpan">unzip.</span>Parse.super_.prototype._transform
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Parse.super_.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('not implemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.super_.prototype._write" id="apidoc.element.unzip.Parse.super_.prototype._write">
        function <span class="apidocSignatureSpan">unzip.</span>Parse.super_.prototype._write
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Parse.super_.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length &lt; rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.super_.prototype.push" id="apidoc.element.unzip.Parse.super_.prototype.push">
        function <span class="apidocSignatureSpan">unzip.</span>Parse.super_.prototype.push
        <span class="apidocSignatureSpan">(chunk, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Parse.super_.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.entry" id="apidoc.element.unzip.entry">
        function <span class="apidocSignatureSpan">unzip.</span>entry
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Entry() {
  PassThrough.call(this);
  this.props = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Extract" id="apidoc.module.unzip.Extract">module unzip.Extract</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Extract.Extract" id="apidoc.element.unzip.Extract.Extract">
        function <span class="apidocSignatureSpan">unzip.</span>Extract
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Extract(opts) {
  var self = this;
  if (!(this instanceof Extract)) {
    return new Extract(opts);
  }

  Writable.apply(this);
  this._opts = opts || { verbose: false };

  this._parser = Parse(this._opts);
  this._parser.on('error', function(err) {
    self.emit('error', err);
  });
  this.on('finish', function() {
    self._parser.end();
  });

  var writer = Writer({
    type: 'Directory',
    path: opts.path
  });
  writer.on('error', function(err) {
    self.emit('error', err);
  });
  writer.on('close', function() {
    self.emit('close')
  });

  this.on('pipe', function(source) {
    if (opts.verbose &amp;&amp; source.path) {
      console.log('Archive: ', source.path);
    }
  });

  this._parser.pipe(writer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
$ npm install unzip
```

## Quick Examples

### Extract to a directory
```javascript
fs.createReadStream('path/to/archive.zip').pipe(unzip.<span class="apidocCodeKeywordSpan">Extract</span>({ path: '
;output/path' }));
```

Extract emits the 'close' event once the zip's contents have been fully extracted to disk.

### Parse zip file contents

Process each zip file entry or pipe entries to another stream.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Extract.super_" id="apidoc.element.unzip.Extract.super_">
        function <span class="apidocSignatureSpan">unzip.Extract.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) &amp;&amp; !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Extract.prototype" id="apidoc.module.unzip.Extract.prototype">module unzip.Extract.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Extract.prototype._write" id="apidoc.element.unzip.Extract.prototype._write">
        function <span class="apidocSignatureSpan">unzip.Extract.prototype.</span>_write
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write = function (chunk, encoding, callback) {
  if (this._parser.write(chunk)) {
    return callback();
  }

  return this._parser.once('drain', callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Extract.prototype._write" id="apidoc.module.unzip.Extract.prototype._write">module unzip.Extract.prototype._write</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Extract.prototype._write._write" id="apidoc.element.unzip.Extract.prototype._write._write">
        function <span class="apidocSignatureSpan">unzip.Extract.prototype.</span>_write
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write = function (chunk, encoding, callback) {
  if (this._parser.write(chunk)) {
    return callback();
  }

  return this._parser.once('drain', callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Extract.super_" id="apidoc.module.unzip.Extract.super_">module unzip.Extract.super_</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Extract.super_.super_" id="apidoc.element.unzip.Extract.super_.super_">
        function <span class="apidocSignatureSpan">unzip.Extract.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream() {
  EE.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Extract.super_.WritableState" id="apidoc.element.unzip.Extract.super_.WritableState">
        function <span class="apidocSignatureSpan">unzip.Extract.super_.</span>WritableState
        <span class="apidocSignatureSpan">(options, stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Extract.super_.prototype" id="apidoc.module.unzip.Extract.super_.prototype">module unzip.Extract.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Extract.super_.prototype._write" id="apidoc.element.unzip.Extract.super_.prototype._write">
        function <span class="apidocSignatureSpan">unzip.Extract.super_.prototype.</span>_write
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write = function (chunk, encoding, cb) {
  cb(new Error('not implemented'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Extract.super_.prototype.end" id="apidoc.element.unzip.Extract.super_.prototype.end">
        function <span class="apidocSignatureSpan">unzip.Extract.super_.prototype.</span>end
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' &amp;&amp; chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending &amp;&amp; !state.finished)
    endWritable(this, state, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Extract.super_.prototype.pipe" id="apidoc.element.unzip.Extract.super_.prototype.pipe">
        function <span class="apidocSignatureSpan">unzip.Extract.super_.prototype.</span>pipe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function () {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
$ npm install unzip
```

## Quick Examples

### Extract to a directory
```javascript
fs.createReadStream('path/to/archive.zip').<span class="apidocCodeKeywordSpan">pipe</span>(unzip.Extract({ path: '
;output/path' }));
```

Extract emits the 'close' event once the zip's contents have been fully extracted to disk.

### Parse zip file contents

Process each zip file entry or pipe entries to another stream.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Extract.super_.prototype.write" id="apidoc.element.unzip.Extract.super_.prototype.write">
        function <span class="apidocSignatureSpan">unzip.Extract.super_.prototype.</span>write
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Extract.super_.prototype._write" id="apidoc.module.unzip.Extract.super_.prototype._write">module unzip.Extract.super_.prototype._write</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Extract.super_.prototype._write._write" id="apidoc.element.unzip.Extract.super_.prototype._write._write">
        function <span class="apidocSignatureSpan">unzip.Extract.super_.prototype.</span>_write
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write = function (chunk, encoding, cb) {
  cb(new Error('not implemented'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Extract.super_.prototype.end" id="apidoc.module.unzip.Extract.super_.prototype.end">module unzip.Extract.super_.prototype.end</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Extract.super_.prototype.end.end" id="apidoc.element.unzip.Extract.super_.prototype.end.end">
        function <span class="apidocSignatureSpan">unzip.Extract.super_.prototype.</span>end
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' &amp;&amp; chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending &amp;&amp; !state.finished)
    endWritable(this, state, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Extract.super_.prototype.pipe" id="apidoc.module.unzip.Extract.super_.prototype.pipe">module unzip.Extract.super_.prototype.pipe</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Extract.super_.prototype.pipe.pipe" id="apidoc.element.unzip.Extract.super_.prototype.pipe.pipe">
        function <span class="apidocSignatureSpan">unzip.Extract.super_.prototype.</span>pipe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function () {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
$ npm install unzip
```

## Quick Examples

### Extract to a directory
```javascript
fs.createReadStream('path/to/archive.zip').<span class="apidocCodeKeywordSpan">pipe</span>(unzip.Extract({ path: '
;output/path' }));
```

Extract emits the 'close' event once the zip's contents have been fully extracted to disk.

### Parse zip file contents

Process each zip file entry or pipe entries to another stream.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Extract.super_.prototype.write" id="apidoc.module.unzip.Extract.super_.prototype.write">module unzip.Extract.super_.prototype.write</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Extract.super_.prototype.write.write" id="apidoc.element.unzip.Extract.super_.prototype.write.write">
        function <span class="apidocSignatureSpan">unzip.Extract.super_.prototype.</span>write
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Parse" id="apidoc.module.unzip.Parse">module unzip.Parse</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Parse.Parse" id="apidoc.element.unzip.Parse.Parse">
        function <span class="apidocSignatureSpan">unzip.</span>Parse
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parse(opts) {
  var self = this;
  if (!(this instanceof Parse)) {
    return new Parse(opts);
  }

  Transform.call(this, { lowWaterMark: 0 });
  this._opts = opts || { verbose: false };
  this._hasEntryListener = false;

  this._pullStream = new PullStream();
  this._pullStream.on("error", function (e) {
    self.emit('error', e);
  });
  this._pullStream.once("end", function () {
    self._streamEnd = true;
  });
  this._pullStream.once("finish", function () {
    self._streamFinish = true;
  });

  this._readRecord();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Process each zip file entry or pipe entries to another stream.

__Important__: If you do not intend to consume an entry stream's raw data, call autodrain() to dispose of the entry's
contents. Otherwise you risk running out of memory.

```javascript
fs.createReadStream('path/to/archive.zip')
.pipe(unzip.<span class="apidocCodeKeywordSpan">Parse</span>())
.on('entry', function (entry) {
  var fileName = entry.path;
  var type = entry.type; // 'Directory' or 'File'
  var size = entry.size;
  if (fileName === "this IS the file I'm looking for") {
    entry.pipe(fs.createWriteStream('output/path'));
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.create" id="apidoc.element.unzip.Parse.create">
        function <span class="apidocSignatureSpan">unzip.Parse.</span>create
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parse(opts) {
  var self = this;
  if (!(this instanceof Parse)) {
    return new Parse(opts);
  }

  Transform.call(this, { lowWaterMark: 0 });
  this._opts = opts || { verbose: false };
  this._hasEntryListener = false;

  this._pullStream = new PullStream();
  this._pullStream.on("error", function (e) {
    self.emit('error', e);
  });
  this._pullStream.once("end", function () {
    self._streamEnd = true;
  });
  this._pullStream.once("finish", function () {
    self._streamFinish = true;
  });

  this._readRecord();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.super_" id="apidoc.element.unzip.Parse.super_">
        function <span class="apidocSignatureSpan">unzip.Parse.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Parse.prototype" id="apidoc.module.unzip.Parse.prototype">module unzip.Parse.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._flush" id="apidoc.element.unzip.Parse.prototype._flush">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_flush
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flush = function (callback) {
  if (!this._streamEnd || !this._streamFinish) {
    return setImmediate(this._flush.bind(this, callback));
  }

  this.emit('close');
  return callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._processDataDescriptor" id="apidoc.element.unzip.Parse.prototype._processDataDescriptor">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_processDataDescriptor
        <span class="apidocSignatureSpan">(entry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processDataDescriptor = function (entry) {
  var self = this;
  this._pullStream.pull(16, function (err, data) {
    if (err) {
      return self.emit('error', err);
    }

    var vars = binary.parse(data)
      .word32lu('dataDescriptorSignature')
      .word32lu('crc32')
      .word32lu('compressedSize')
      .word32lu('uncompressedSize')
      .vars;

    entry.size = vars.uncompressedSize;
    self._readRecord();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._readCentralDirectoryFileHeader" id="apidoc.element.unzip.Parse.prototype._readCentralDirectoryFileHeader">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_readCentralDirectoryFileHeader
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_readCentralDirectoryFileHeader = function () {
  var self = this;
  this._pullStream.pull(42, function (err, data) {
    if (err) {
      return self.emit('error', err);
    }

    var vars = binary.parse(data)
      .word16lu('versionMadeBy')
      .word16lu('versionsNeededToExtract')
      .word16lu('flags')
      .word16lu('compressionMethod')
      .word16lu('lastModifiedTime')
      .word16lu('lastModifiedDate')
      .word32lu('crc32')
      .word32lu('compressedSize')
      .word32lu('uncompressedSize')
      .word16lu('fileNameLength')
      .word16lu('extraFieldLength')
      .word16lu('fileCommentLength')
      .word16lu('diskNumber')
      .word16lu('internalFileAttributes')
      .word32lu('externalFileAttributes')
      .word32lu('offsetToLocalFileHeader')
      .vars;

    return self._pullStream.pull(vars.fileNameLength, function (err, fileName) {
      if (err) {
        return self.emit('error', err);
      }
      fileName = fileName.toString('utf8');

      self._pullStream.pull(vars.extraFieldLength, function (err, extraField) {
        if (err) {
          return self.emit('error', err);
        }
        self._pullStream.pull(vars.fileCommentLength, function (err, fileComment) {
          if (err) {
            return self.emit('error', err);
          }
          return self._readRecord();
        });
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._readEndOfCentralDirectoryRecord" id="apidoc.element.unzip.Parse.prototype._readEndOfCentralDirectoryRecord">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_readEndOfCentralDirectoryRecord
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_readEndOfCentralDirectoryRecord = function () {
  var self = this;
  this._pullStream.pull(18, function (err, data) {
    if (err) {
      return self.emit('error', err);
    }

    var vars = binary.parse(data)
      .word16lu('diskNumber')
      .word16lu('diskStart')
      .word16lu('numberOfRecordsOnDisk')
      .word16lu('numberOfRecords')
      .word32lu('sizeOfCentralDirectory')
      .word32lu('offsetToStartOfCentralDirectory')
      .word16lu('commentLength')
      .vars;

    if (vars.commentLength) {
      setImmediate(function() {
        self._pullStream.pull(vars.commentLength, function (err, comment) {
          if (err) {
            return self.emit('error', err);
          }
          comment = comment.toString('utf8');
          return self._pullStream.end();
        });
      });

    } else {
      self._pullStream.end();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._readFile" id="apidoc.element.unzip.Parse.prototype._readFile">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_readFile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_readFile = function () {
  var self = this;
  this._pullStream.pull(26, function (err, data) {
    if (err) {
      return self.emit('error', err);
    }

    var vars = binary.parse(data)
      .word16lu('versionsNeededToExtract')
      .word16lu('flags')
      .word16lu('compressionMethod')
      .word16lu('lastModifiedTime')
      .word16lu('lastModifiedDate')
      .word32lu('crc32')
      .word32lu('compressedSize')
      .word32lu('uncompressedSize')
      .word16lu('fileNameLength')
      .word16lu('extraFieldLength')
      .vars;

    return self._pullStream.pull(vars.fileNameLength, function (err, fileName) {
      if (err) {
        return self.emit('error', err);
      }
      fileName = fileName.toString('utf8');
      var entry = new Entry();
      entry.path = fileName;
      entry.props.path = fileName;
      entry.type = (vars.compressedSize === 0 &amp;&amp; /[\/\\]$/.test(fileName)) ? 'Directory' : 'File';

      if (self._opts.verbose) {
        if (entry.type === 'Directory') {
          console.log('   creating:', fileName);
        } else if (entry.type === 'File') {
          if (vars.compressionMethod === 0) {
            console.log(' extracting:', fileName);
          } else {
            console.log('  inflating:', fileName);
          }
        }
      }

      var hasEntryListener = self._hasEntryListener;
      if (hasEntryListener) {
        self.emit('entry', entry);
      }

      self._pullStream.pull(vars.extraFieldLength, function (err, extraField) {
        if (err) {
          return self.emit('error', err);
        }
        if (vars.compressionMethod === 0) {
          self._pullStream.pull(vars.compressedSize, function (err, compressedData) {
            if (err) {
              return self.emit('error', err);
            }

            if (hasEntryListener) {
              entry.write(compressedData);
              entry.end();
            }

            return self._readRecord();
          });
        } else {
          var fileSizeKnown = !(vars.flags &amp; 0x08);

          var inflater = zlib.createInflateRaw();
          inflater.on('error', function (err) {
            self.emit('error', err);
          });

          if (fileSizeKnown) {
            entry.size = vars.uncompressedSize;
            if (hasEntryListener) {
              entry.on('finish', self._readRecord.bind(self));
              self._pullStream.pipe(vars.compressedSize, inflater).pipe(entry);
            } else {
              self._pullStream.drain(vars.compressedSize, function (err) {
                if (err) {
                  return self.emit('error', err);
                }
                self._readRecord();
              });
            }
          } else {
            var descriptorSig = new Buffer(4);
            descriptorSig.writeUInt32LE(0x08074b50, 0);

            var matchStream = new MatchStream({ pattern: descriptorSig }, function (buf, matched, extra) {
              if (hasEntryListener) {
                if (!matched) {
                  return this.push(buf);
                }
                this.push(buf);
              }
              setImmediate(function() {
                self._pullStream.unpipe();
                self._pullStream.prepend(extra);
                self._processDataDescriptor(entry);
              });
              return this.push(null);
            });

            self._pullStream.pipe(matchStream);
            if (hasEntryListener) {
              matchStream.pipe(inflater).pipe(entry);
            }
          }
        }
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._readRecord" id="apidoc.element.unzip.Parse.prototype._readRecord">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_readRecord
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_readRecord = function () {
  var self = this;
  this._pullStream.pull(4, function (err, data) {
    if (err) {
      return self.emit('error', err);
    }

    if (data.length === 0) {
      return;
    }

    var signature = data.readUInt32LE(0);
    if (signature === 0x04034b50) {
      self._readFile();
    } else if (signature === 0x02014b50) {
      self._readCentralDirectoryFileHeader();
    } else if (signature === 0x06054b50) {
      self._readEndOfCentralDirectoryRecord();
    } else {
      err = new Error('invalid signature: 0x' + signature.toString(16));
      self.emit('error', err);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._transform" id="apidoc.element.unzip.Parse.prototype._transform">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, callback) {
  if (this._pullStream.write(chunk)) {
    return callback();
  }

  this._pullStream.once('drain', callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype.addListener" id="apidoc.element.unzip.Parse.prototype.addListener">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>addListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function (type, listener) {
  if ('entry' === type) {
    this._hasEntryListener = true;
  }
  return Transform.prototype.addListener.call(this, type, listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype.on" id="apidoc.element.unzip.Parse.prototype.on">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>on
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (type, listener) {
  if ('entry' === type) {
    this._hasEntryListener = true;
  }
  return Transform.prototype.addListener.call(this, type, listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

__Important__: If you do not intend to consume an entry stream's raw data, call autodrain() to dispose of the entry's
contents. Otherwise you risk running out of memory.

```javascript
fs.createReadStream('path/to/archive.zip')
.pipe(unzip.Parse())
.<span class="apidocCodeKeywordSpan">on</span>('entry', function (entry) {
  var fileName = entry.path;
  var type = entry.type; // 'Directory' or 'File'
  var size = entry.size;
  if (fileName === "this IS the file I'm looking for") {
    entry.pipe(fs.createWriteStream('output/path'));
  } else {
    entry.autodrain();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype.pipe" id="apidoc.element.unzip.Parse.prototype.pipe">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>pipe
        <span class="apidocSignatureSpan">(dest, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function (dest, opts) {
  var self = this;
  if (typeof dest.add === "function") {
    self.on("entry", function (entry) {
      dest.add(entry);
    })
  }
  return Transform.prototype.pipe.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
$ npm install unzip
```

## Quick Examples

### Extract to a directory
```javascript
fs.createReadStream('path/to/archive.zip').<span class="apidocCodeKeywordSpan">pipe</span>(unzip.Extract({ path: '
;output/path' }));
```

Extract emits the 'close' event once the zip's contents have been fully extracted to disk.

### Parse zip file contents

Process each zip file entry or pipe entries to another stream.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Parse.prototype._flush" id="apidoc.module.unzip.Parse.prototype._flush">module unzip.Parse.prototype._flush</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._flush._flush" id="apidoc.element.unzip.Parse.prototype._flush._flush">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_flush
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_flush = function (callback) {
  if (!this._streamEnd || !this._streamFinish) {
    return setImmediate(this._flush.bind(this, callback));
  }

  this.emit('close');
  return callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Parse.prototype._processDataDescriptor" id="apidoc.module.unzip.Parse.prototype._processDataDescriptor">module unzip.Parse.prototype._processDataDescriptor</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._processDataDescriptor._processDataDescriptor" id="apidoc.element.unzip.Parse.prototype._processDataDescriptor._processDataDescriptor">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_processDataDescriptor
        <span class="apidocSignatureSpan">(entry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processDataDescriptor = function (entry) {
  var self = this;
  this._pullStream.pull(16, function (err, data) {
    if (err) {
      return self.emit('error', err);
    }

    var vars = binary.parse(data)
      .word32lu('dataDescriptorSignature')
      .word32lu('crc32')
      .word32lu('compressedSize')
      .word32lu('uncompressedSize')
      .vars;

    entry.size = vars.uncompressedSize;
    self._readRecord();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Parse.prototype._readCentralDirectoryFileHeader" id="apidoc.module.unzip.Parse.prototype._readCentralDirectoryFileHeader">module unzip.Parse.prototype._readCentralDirectoryFileHeader</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._readCentralDirectoryFileHeader._readCentralDirectoryFileHeader" id="apidoc.element.unzip.Parse.prototype._readCentralDirectoryFileHeader._readCentralDirectoryFileHeader">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_readCentralDirectoryFileHeader
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_readCentralDirectoryFileHeader = function () {
  var self = this;
  this._pullStream.pull(42, function (err, data) {
    if (err) {
      return self.emit('error', err);
    }

    var vars = binary.parse(data)
      .word16lu('versionMadeBy')
      .word16lu('versionsNeededToExtract')
      .word16lu('flags')
      .word16lu('compressionMethod')
      .word16lu('lastModifiedTime')
      .word16lu('lastModifiedDate')
      .word32lu('crc32')
      .word32lu('compressedSize')
      .word32lu('uncompressedSize')
      .word16lu('fileNameLength')
      .word16lu('extraFieldLength')
      .word16lu('fileCommentLength')
      .word16lu('diskNumber')
      .word16lu('internalFileAttributes')
      .word32lu('externalFileAttributes')
      .word32lu('offsetToLocalFileHeader')
      .vars;

    return self._pullStream.pull(vars.fileNameLength, function (err, fileName) {
      if (err) {
        return self.emit('error', err);
      }
      fileName = fileName.toString('utf8');

      self._pullStream.pull(vars.extraFieldLength, function (err, extraField) {
        if (err) {
          return self.emit('error', err);
        }
        self._pullStream.pull(vars.fileCommentLength, function (err, fileComment) {
          if (err) {
            return self.emit('error', err);
          }
          return self._readRecord();
        });
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Parse.prototype._readEndOfCentralDirectoryRecord" id="apidoc.module.unzip.Parse.prototype._readEndOfCentralDirectoryRecord">module unzip.Parse.prototype._readEndOfCentralDirectoryRecord</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._readEndOfCentralDirectoryRecord._readEndOfCentralDirectoryRecord" id="apidoc.element.unzip.Parse.prototype._readEndOfCentralDirectoryRecord._readEndOfCentralDirectoryRecord">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_readEndOfCentralDirectoryRecord
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_readEndOfCentralDirectoryRecord = function () {
  var self = this;
  this._pullStream.pull(18, function (err, data) {
    if (err) {
      return self.emit('error', err);
    }

    var vars = binary.parse(data)
      .word16lu('diskNumber')
      .word16lu('diskStart')
      .word16lu('numberOfRecordsOnDisk')
      .word16lu('numberOfRecords')
      .word32lu('sizeOfCentralDirectory')
      .word32lu('offsetToStartOfCentralDirectory')
      .word16lu('commentLength')
      .vars;

    if (vars.commentLength) {
      setImmediate(function() {
        self._pullStream.pull(vars.commentLength, function (err, comment) {
          if (err) {
            return self.emit('error', err);
          }
          comment = comment.toString('utf8');
          return self._pullStream.end();
        });
      });

    } else {
      self._pullStream.end();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Parse.prototype._readFile" id="apidoc.module.unzip.Parse.prototype._readFile">module unzip.Parse.prototype._readFile</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._readFile._readFile" id="apidoc.element.unzip.Parse.prototype._readFile._readFile">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_readFile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_readFile = function () {
  var self = this;
  this._pullStream.pull(26, function (err, data) {
    if (err) {
      return self.emit('error', err);
    }

    var vars = binary.parse(data)
      .word16lu('versionsNeededToExtract')
      .word16lu('flags')
      .word16lu('compressionMethod')
      .word16lu('lastModifiedTime')
      .word16lu('lastModifiedDate')
      .word32lu('crc32')
      .word32lu('compressedSize')
      .word32lu('uncompressedSize')
      .word16lu('fileNameLength')
      .word16lu('extraFieldLength')
      .vars;

    return self._pullStream.pull(vars.fileNameLength, function (err, fileName) {
      if (err) {
        return self.emit('error', err);
      }
      fileName = fileName.toString('utf8');
      var entry = new Entry();
      entry.path = fileName;
      entry.props.path = fileName;
      entry.type = (vars.compressedSize === 0 &amp;&amp; /[\/\\]$/.test(fileName)) ? 'Directory' : 'File';

      if (self._opts.verbose) {
        if (entry.type === 'Directory') {
          console.log('   creating:', fileName);
        } else if (entry.type === 'File') {
          if (vars.compressionMethod === 0) {
            console.log(' extracting:', fileName);
          } else {
            console.log('  inflating:', fileName);
          }
        }
      }

      var hasEntryListener = self._hasEntryListener;
      if (hasEntryListener) {
        self.emit('entry', entry);
      }

      self._pullStream.pull(vars.extraFieldLength, function (err, extraField) {
        if (err) {
          return self.emit('error', err);
        }
        if (vars.compressionMethod === 0) {
          self._pullStream.pull(vars.compressedSize, function (err, compressedData) {
            if (err) {
              return self.emit('error', err);
            }

            if (hasEntryListener) {
              entry.write(compressedData);
              entry.end();
            }

            return self._readRecord();
          });
        } else {
          var fileSizeKnown = !(vars.flags &amp; 0x08);

          var inflater = zlib.createInflateRaw();
          inflater.on('error', function (err) {
            self.emit('error', err);
          });

          if (fileSizeKnown) {
            entry.size = vars.uncompressedSize;
            if (hasEntryListener) {
              entry.on('finish', self._readRecord.bind(self));
              self._pullStream.pipe(vars.compressedSize, inflater).pipe(entry);
            } else {
              self._pullStream.drain(vars.compressedSize, function (err) {
                if (err) {
                  return self.emit('error', err);
                }
                self._readRecord();
              });
            }
          } else {
            var descriptorSig = new Buffer(4);
            descriptorSig.writeUInt32LE(0x08074b50, 0);

            var matchStream = new MatchStream({ pattern: descriptorSig }, function (buf, matched, extra) {
              if (hasEntryListener) {
                if (!matched) {
                  return this.push(buf);
                }
                this.push(buf);
              }
              setImmediate(function() {
                self._pullStream.unpipe();
                self._pullStream.prepend(extra);
                self._processDataDescriptor(entry);
              });
              return this.push(null);
            });

            self._pullStream.pipe(matchStream);
            if (hasEntryListener) {
              matchStream.pipe(inflater).pipe(entry);
            }
          }
        }
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Parse.prototype._readRecord" id="apidoc.module.unzip.Parse.prototype._readRecord">module unzip.Parse.prototype._readRecord</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._readRecord._readRecord" id="apidoc.element.unzip.Parse.prototype._readRecord._readRecord">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_readRecord
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_readRecord = function () {
  var self = this;
  this._pullStream.pull(4, function (err, data) {
    if (err) {
      return self.emit('error', err);
    }

    if (data.length === 0) {
      return;
    }

    var signature = data.readUInt32LE(0);
    if (signature === 0x04034b50) {
      self._readFile();
    } else if (signature === 0x02014b50) {
      self._readCentralDirectoryFileHeader();
    } else if (signature === 0x06054b50) {
      self._readEndOfCentralDirectoryRecord();
    } else {
      err = new Error('invalid signature: 0x' + signature.toString(16));
      self.emit('error', err);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Parse.prototype._transform" id="apidoc.module.unzip.Parse.prototype._transform">module unzip.Parse.prototype._transform</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype._transform._transform" id="apidoc.element.unzip.Parse.prototype._transform._transform">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, callback) {
  if (this._pullStream.write(chunk)) {
    return callback();
  }

  this._pullStream.once('drain', callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Parse.prototype.addListener" id="apidoc.module.unzip.Parse.prototype.addListener">module unzip.Parse.prototype.addListener</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype.addListener.addListener" id="apidoc.element.unzip.Parse.prototype.addListener.addListener">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>addListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function (type, listener) {
  if ('entry' === type) {
    this._hasEntryListener = true;
  }
  return Transform.prototype.addListener.call(this, type, listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Parse.prototype.pipe" id="apidoc.module.unzip.Parse.prototype.pipe">module unzip.Parse.prototype.pipe</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Parse.prototype.pipe.pipe" id="apidoc.element.unzip.Parse.prototype.pipe.pipe">
        function <span class="apidocSignatureSpan">unzip.Parse.prototype.</span>pipe
        <span class="apidocSignatureSpan">(dest, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function (dest, opts) {
  var self = this;
  if (typeof dest.add === "function") {
    self.on("entry", function (entry) {
      dest.add(entry);
    })
  }
  return Transform.prototype.pipe.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
$ npm install unzip
```

## Quick Examples

### Extract to a directory
```javascript
fs.createReadStream('path/to/archive.zip').<span class="apidocCodeKeywordSpan">pipe</span>(unzip.Extract({ path: '
;output/path' }));
```

Extract emits the 'close' event once the zip's contents have been fully extracted to disk.

### Parse zip file contents

Process each zip file entry or pipe entries to another stream.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Parse.super_" id="apidoc.module.unzip.Parse.super_">module unzip.Parse.super_</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Parse.super_.super_" id="apidoc.element.unzip.Parse.super_.super_">
        function <span class="apidocSignatureSpan">unzip.Parse.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options &amp;&amp; options.readable === false)
    this.readable = false;

  if (options &amp;&amp; options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options &amp;&amp; options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Parse.super_.prototype" id="apidoc.module.unzip.Parse.super_.prototype">module unzip.Parse.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Parse.super_.prototype._read" id="apidoc.element.unzip.Parse.super_.prototype._read">
        function <span class="apidocSignatureSpan">unzip.Parse.super_.prototype.</span>_read
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null &amp;&amp; ts.writecb &amp;&amp; !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.super_.prototype._transform" id="apidoc.element.unzip.Parse.super_.prototype._transform">
        function <span class="apidocSignatureSpan">unzip.Parse.super_.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, cb) {
  throw new Error('not implemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.super_.prototype._write" id="apidoc.element.unzip.Parse.super_.prototype._write">
        function <span class="apidocSignatureSpan">unzip.Parse.super_.prototype.</span>_write
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length &lt; rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.super_.prototype.push" id="apidoc.element.unzip.Parse.super_.prototype.push">
        function <span class="apidocSignatureSpan">unzip.Parse.super_.prototype.</span>push
        <span class="apidocSignatureSpan">(chunk, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Parse.super_.prototype._read" id="apidoc.module.unzip.Parse.super_.prototype._read">module unzip.Parse.super_.prototype._read</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Parse.super_.prototype._read._read" id="apidoc.element.unzip.Parse.super_.prototype._read._read">
        function <span class="apidocSignatureSpan">unzip.Parse.super_.prototype.</span>_read
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null &amp;&amp; ts.writecb &amp;&amp; !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Parse.super_.prototype._transform" id="apidoc.module.unzip.Parse.super_.prototype._transform">module unzip.Parse.super_.prototype._transform</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Parse.super_.prototype._transform._transform" id="apidoc.element.unzip.Parse.super_.prototype._transform._transform">
        function <span class="apidocSignatureSpan">unzip.Parse.super_.prototype.</span>_transform
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_transform = function (chunk, encoding, cb) {
  throw new Error('not implemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Parse.super_.prototype._write" id="apidoc.module.unzip.Parse.super_.prototype._write">module unzip.Parse.super_.prototype._write</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Parse.super_.prototype._write._write" id="apidoc.element.unzip.Parse.super_.prototype._write._write">
        function <span class="apidocSignatureSpan">unzip.Parse.super_.prototype.</span>_write
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length &lt; rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Parse.super_.prototype.push" id="apidoc.module.unzip.Parse.super_.prototype.push">module unzip.Parse.super_.prototype.push</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Parse.super_.prototype.push.push" id="apidoc.element.unzip.Parse.super_.prototype.push.push">
        function <span class="apidocSignatureSpan">unzip.Parse.super_.prototype.</span>push
        <span class="apidocSignatureSpan">(chunk, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.Parse.super_.super_.prototype" id="apidoc.module.unzip.Parse.super_.super_.prototype">module unzip.Parse.super_.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.Parse.super_.super_.prototype._write" id="apidoc.element.unzip.Parse.super_.super_.prototype._write">
        function <span class="apidocSignatureSpan">unzip.Parse.super_.super_.prototype.</span>_write
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write = function (chunk, encoding, cb) {
  cb(new Error('not implemented'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.super_.super_.prototype.end" id="apidoc.element.unzip.Parse.super_.super_.prototype.end">
        function <span class="apidocSignatureSpan">unzip.Parse.super_.super_.prototype.</span>end
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' &amp;&amp; chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending &amp;&amp; !state.finished)
    endWritable(this, state, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.Parse.super_.super_.prototype.write" id="apidoc.element.unzip.Parse.super_.super_.prototype.write">
        function <span class="apidocSignatureSpan">unzip.Parse.super_.super_.prototype.</span>write
        <span class="apidocSignatureSpan">(chunk, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.entry" id="apidoc.module.unzip.entry">module unzip.entry</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.entry.entry" id="apidoc.element.unzip.entry.entry">
        function <span class="apidocSignatureSpan">unzip.</span>entry
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Entry() {
  PassThrough.call(this);
  this.props = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.unzip.entry.super_" id="apidoc.element.unzip.entry.super_">
        function <span class="apidocSignatureSpan">unzip.entry.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.unzip.entry.prototype" id="apidoc.module.unzip.entry.prototype">module unzip.entry.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.unzip.entry.prototype.autodrain" id="apidoc.element.unzip.entry.prototype.autodrain">
        function <span class="apidocSignatureSpan">unzip.entry.prototype.</span>autodrain
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autodrain = function () {
  this.on('readable', this.read.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .on('entry', function (entry) {
    var fileName = entry.path;
    var type = entry.type; // 'Directory' or 'File'
    var size = entry.size;
    if (fileName === "this IS the file I'm looking for") {
      entry.pipe(fs.createWriteStream('output/path'));
    } else {
      entry.<span class="apidocCodeKeywordSpan">autodrain</span>();
    }
  });
```

Or pipe the output of unzip.Parse() to fstream

```javascript
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>